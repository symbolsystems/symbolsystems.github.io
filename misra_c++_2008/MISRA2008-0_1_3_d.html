<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
A project should not contain unused variables with external linkage [MISRA2008-0_1_3_d]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
A project should not contain unused variables with external linkage [MISRA2008-0_1_3_d-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"Variables declared and never used in a project constitute noise and may
indicate that the wrong name has been used somewhere. Removing these
declarations reduces the possibility that they may later be used instead
of the correct variable." [MISRA C++:2008 Rule 0-1-3]

This rule detects variables with external linkage that are not used in
a testing scope.

See also: OPT-43



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

2023.1



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

Objects of non-POD type can perform some actions in their constructors.
Even if they are not used later they might have done their job during
creation. This rule considers such objects as used.

This rule considers variables to be of POD type according to the definition
of POD (Plain Old Data) specified in:
- the MISRA C++:2008 (Appendix C) standard
- the C++ ISO/IEC 14882:1998 standard (for cases not defined by MISRA C++:2008)

The rule does not trigger on variables captured by lambda expressions. 
It assumes that lambdas use every variable they capture.

The rule analyzes declarations and definitions in files in the testing scope.
For this reason, the set of findings reported for the same file may vary
depending on the scope of analysis.

The rule operates on all files in the testing scope. For this reason, it is
important to specify a testing scope that reflects the system architecture
(for example, it may be appropriate to define a testing scope that corresponds
to a single, complete, linkable module).



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

The rule improves legibility and increases the efficiency of code.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

// header.h

int var1;                         /* Violation */
int var2;                         /* Violation */

// file1.cpp

#include "header.h"

int addVar1toParam(int param)
{
  return param + param;
}

// file2.cpp

#include "header.h"

int var3 = 0;                     /* Violation */

int foo(void)
{
  return 0;
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* You can fix the code by removing the unused variable or by using it */

// header.h

int var1;                         /* OK */

// file1.cpp

#include "header.h"

int addVar1toParam(int param)
{
  return var1 + param;
}

// file2.cpp

#include "header.h"

int var3 = 0;                     /* OK */

void foo(void)
{
  return var3;
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. AUTOSAR C++14 Coding Guidelines
   M0-1-3. A project shall not contain unused variables

2. ISO/IEC 14882:1998 Programming languages -- C++
   3.9 Types, 9 Classes
   
3. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 0, Rule 0-1-3

4. MISRA C:2012 Amendment 4 Updates for ISO/IEC 9899:2011/2018
   Phase 3 - Multi-threading and atomics
   2.2 Section 8 - Rules, 2.2.1 Rule 2.8

</PRE>
</BODY>
</HTML>
