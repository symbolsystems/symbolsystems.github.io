<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
User-specified C internal identifiers should differ from external identifiers in the first 31 characters [MISRA2004-5_1_b]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
User-specified C internal identifiers should differ from external identifiers in the first 31 characters [MISRA2004-5_1_b-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The ISO standard requires internal identifiers to be distinct in the first 31
characters to guarantee code portability. This limitation shall not be exceeded,
even if the compiler supports it. This rule shall apply across all name spaces.
The ISO standard requires external identifiers to be distinct in the first 6
characters, regardless of case, to guarantee optimal portability.
However this limitation is particularly severe and is considered unnecessary.
The intent of this rule is to sanction a relaxation of the ISO requirement
to a degree commensurate with modern environments and it shall be confirmed
that 31 character/case significance is supported by the implementation."
[MISRA C:2004 Rule 5.1]

This rule detects when an internal identifier has the same first 31 characters
in its name as an external identifier declared or defined in the same
translation unit.

The rule checks the following external identifiers:
- variables and functions with internal or external linkage
- classes, structures, unions, typedefs, enumerations, and enumeration
  constants that are defined in a file scope

The rule checks the following internal identifiers:
- variables and functions with no linkage
- function parameters
- labels
- classes, structures, unions, typedefs, enums, and enumeration constants
  that are defined in a block scope



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

2020.2



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule compares identifiers across all name spaces.
The rule does not report identifiers with identical names.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

This rule helps you improve code portability.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

void NE_4567890123456789012345678901_v1();
void f1() {
    int NE_4567890123456789012345678901_v2;       // Violation
}

static void NS_4567890123456789012345678901_v1();
void f2(int NS_4567890123456789012345678901_v2);  // Violation



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

You can fix the code by modifying the names of identifiers.

void NE_4567890123456789012345678901_v1();
void f1() {
    int NL_4567890123456789012345678901_v2;        // OK
}

static void NS_4567890123456789012345678901_v1();
void f2(int NP_4567890123456789012345678901_v2);  // OK



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 5, Rule 5.1

2. Origin: Misra Guidelines - Rule 11

</PRE>
</BODY>
</HTML>
