<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Avoid implicit conversions from wider to narrower types [MISRA2004-10_1_d]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid implicit conversions from wider to narrower types [MISRA2004-10_1_d-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"The value of an expression of integer type shall not be implicitly converted
to a different underlying type if:
a) it is not a conversion to a wider integer type of the same signedness
b) the expression is complex, or
c) the expression is not constant and is a function argument, or
d) the expression is not constant and is a return expression."
[MISRA C:2004, Rule 10.1]

This rule detects when the value of an expression of integer type is assigned
to an object with a narrower underlying type.

"The term 'underlying type' is defined as describing the type that would
be obtained from evaluating an expression if it were not for the effects
of integral promotion." [MISRA C:2004, Underlying type]



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v7.0



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The following operations are covered by this rule:
- Assignment by means of one of the assignment operators.
- Passing an argument to a function where the argument is copied as 
  if by assignment to the corresponding parameter.
- Returning an expression from a function where the result is copied
  as if by assignment to an object with the function's return type.
- Using an expression to initialize an object or part of an object, including
  a compound literal in C99, where the expression is copied as if by 
  assignment to the destination.
- Conversion of the constant expression in the case label of a switch statement
  to the promoted type of the controlling expression.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

This rule helps you prevent data loss.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

unsigned short ret_u16a(signed int i);

signed int foo1 ( unsigned int u32a, unsigned long long u64a ) {
    unsigned char u8a = 255;         /* Violation */
    unsigned short u16a = u32a + 1;  /* Violation */

    u16a = u32a;                     /* Violation */
    u8a  = ret_u16a(u64a);           /* Violation */
    
    return u64a;                     /* Violation */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* Examples of correct code */
short ret_u16a(signed int i);

signed int foo1 ( unsigned int u32a, unsigned long u32a_long ) {
    unsigned char u8a = 255u;                           /* OK */
    unsigned short u16a = (unsigned short)(u32a + 1u);  /* OK */

    /* The 'underlying type' of the expression 'u8a + u8a' is unsigned char */
    u16a = u8a + u8a;        /* OK */
    u16a  = ret_u16a(u32a);  /* OK - this rule does not report violations on
                                     conversions between signed and unsigned
                                     types if they have the same size */
    
    return u32a_long;        /* OK - if 'int' and 'long' have the same size */
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 10.6, Rule 10.1

2. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 10.4, Underlying type

</PRE>
</BODY>
</HTML>
