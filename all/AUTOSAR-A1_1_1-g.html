<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Prefer to use std::unique_ptr instead of std::auto_ptr [AUTOSAR-A1_1_1-g]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Prefer to use std::unique_ptr instead of std::auto_ptr [AUTOSAR-A1_1_1-g-2]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

auto_ptr is deprecated under C++11 and completely removed from C++17. The copy
constructor and assignment operators of auto_ptr do not actually copy the stored
pointer. Instead, they transfer it, leaving the prior auto_ptr object empty.
This was one way to implement strict ownership, so that only one auto_ptr object
can own the pointer at any given time. This means that auto_ptr should not be
used where copy semantics are needed.

unique_ptr is a new, improved and much safer version of auto_ptr. A unique_ptr
is a container for a raw pointer, which the unique_ptr is said to own.
A unique_ptr explicitly prevents copying of its contained pointer, but the move
function can be used to transfer ownership of the contained pointer to another
unique_ptr. A unique_ptr cannot be copied because its copy constructor
and assignment operators are explicitly deleted.

If you need a single-owner smart pointer class, you should use unique_ptr, not
auto_ptr.

This rule detect when auto_ptr is used.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v10.3



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

  1. You can assign a custom deleter to unique_ptr to specify certain behavior
     to be executed instead of calling the standard delete when the object is
     being destroyed.
  2. Copy assignment is not allowed for unique_ptr. Ownership is truly unique
     and safe.
  3. unique_ptr can be used in STL containers.
  4. Converting a unique_ptr to a shared_ptr is easy.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

#include &lt;memory&gt;

class A{};
class B : public A
{
public:
    std::auto_ptr&lt;A&gt;* foo()                             // Violation
    {
        return 0;
    }
};

using auto_ptr_a = std::auto_ptr&lt;A&gt;****;                // Violation

void foo(std::auto_ptr&lt;B&gt; p)                            // Violation
{
    auto_ptr_a a;

    std::auto_ptr&lt;A&gt; b;                                 // Violation
    b = *(p.get()-&gt;foo());
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

#include &lt;memory&gt;

class A{};
class B : public A
{
public:
    std::unique_ptr&lt;A&gt;* foo()                             // OK
    {
        return 0;
    }
};

using auto_ptr_a = std::unique_ptr&lt;A&gt;****;                // OK

void foo(std::unique_ptr&lt;B&gt; p)                            // OK
{
    auto_ptr_a a;

    std::unique_ptr&lt;A&gt; b;                                 // OK
    b = std::move(p);
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. AUTOSAR C++14 Coding Guidelines
   A18-1-3. The std::auto_ptr type shall not be used

2. Scott Meyers, "Effective Modern C++, 42 specific ways to improve your use
   of C++11 and C++14", O'Reilly Media, Inc., Copyright 2015,
   Chapter 4: "Smart Pointers.",
   Item 18: "Use std::unique_ptr for exclusive-ownership resource management."

3. AUTOSAR C++14 Coding Guidelines
   A1-1-1. All code shall conform to ISO/IEC 14882:2014 - Programming Language
   C++ and shall not use deprecated features.

4. Programming languages -- C++ ISO/IEC 14882:2011
   D.10 auto_ptr

5. Programming languages -- C++ ISO/IEC 14882:2014 
   D.10 auto_ptr

</PRE>
</BODY>
</HTML>
