<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Do not return from a computational exception signal handler [CERT_C-SIG35-a]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Do not return from a computational exception signal handler [CERT_C-SIG35-a-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
This rule detects returns of functions registered as signal handlers that should never return.
	
"The behavior of a process is undefined after it returns normally from a signal-catching function for
a SIGBUS, SIGFPE, SIGILL, or SIGSEGV signal that was not generated by kill(), sigqueue(), or raise()."
[SEI CERT C Coding Standard, 
SIG35-C. Do not return from a computational exception signal handler]


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v10.4.0


</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
SECURITY RELEVANCE
</STRONG>
<PRE>
Returning from a function that should never return
results in undefined behavior that might be exploited.


</PRE>
<STRONG>
PARAMETERS
</STRONG>
<PRE>
The "Values corresponding to signal handlers that should not return" parameter allows you to configure
integer values corresponding to signals. The rule will trigger only if a signal handler is registered
for the specified signal value(s).
The defaults are values commonly used for SIGILL(4), SIGFPE(8) and SIGSEGV(11). You can overwrite them
with values specific to your environment, or add additional, implementation-defined, computational
exception signals, such as SIGBUS.


</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>
Helps you avoid unexpected failures at runtime. The Standard does not define behavior
if a function that should not return returns, which may lead to unexpected behaviors.


</PRE>
<STRONG>
DRAWBACKS
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;

volatile sig_atomic_t denom;

void sighandle(int s) {
    /* Fix the offending volatile */
    if (denom == 0) {
        denom = 1;
    }
} // VIOLATION

int main(int argc, char *argv[]) {
    if (argc &lt; 2) {
        return 0;
    }
    char *end = NULL;
    long temp = strtol(argv[1], &amp;end, 10);
    if (end == argv[1] || 0 != *end
            || ((LONG_MIN == temp || LONG_MAX == temp) &amp;&amp; errno == ERANGE)) {
        /* Handle error */
    }
    denom = (sig_atomic_t) temp;
    signal(SIGFPE, sighandle);
    long result = 100 / (long) denom;
    return 0;
}


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>
#include &lt;errno.h&gt;
#include &lt;limits.h&gt;
#include &lt;signal.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    if (argc &lt; 2) {
        return 0;
    }
    char *end = NULL;
    long denom = strtol(argv[1], &amp;end, 10);
    if (end == argv[1] || 0 != *end
            || ((LONG_MIN == denom || LONG_MAX == denom) &amp;&amp; errno == ERANGE)) {
        /* Handle error */
    }
    long result = 100 / denom;
    return 0;
}


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>
SEI CERT C Coding Standard
SIG35-C. Do not return from a computational exception signal handler
<A HREF="https://wiki.sei.cmu.edu/confluence/display/c/SIG35-C.+Do+not+return+from+a+computational+exception+signal+handler">https://wiki.sei.cmu.edu/confluence/display/c/SIG35-C.+Do+not+return+from+a+computational+exception+signal+handler</A>

</PRE>
</BODY>
</HTML>
