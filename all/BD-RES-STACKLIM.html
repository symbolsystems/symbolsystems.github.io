<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Do not create variables on the stack above the defined limits [BD-RES-STACKLIM]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Do not create variables on the stack above the defined limits [BD-RES-STACKLIM-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
This rule detects when one of the following takes up more space on the 
stack than the defined limit:
- single variable
- sum of parameters sizes
- sum of all local variables and parameters in scope of one method 
(without entering to nested methods).



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v10.1


</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
SECURITY RELEVANCE
</STRONG>
<PRE>
This rule prevents defects that can expose the application to denial of 
service attacks.


</PRE>
<STRONG>
PARAMETERS
</STRONG>
<PRE>
"Single variable size" defines limit for maximal variable size.
    It is set to 4096 by default. 
        
"Sum of all parameters sizes" defines limit for maximal sum of all method 
parameters sizes.
    It is set to 256 by default. 
        
"Sum of all method local variables and parameters sizes" defines limit for 
all local variables and method parameters sizes.
    It is set to 20480 by default. 


</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>
This rule helps to avoid stack overflow errors.


</PRE>
<STRONG>
DRAWBACKS
</STRONG>
<PRE>
This rule only estimates the sum of all local variables size from one 
method or sum of sizes of all parameters. 
This rule does not assume that the compiler could do any optimization 
(i.e., add simple parameters from a simple method only to registers and 
never put them on the stack). Additionally, this rule does not take 
into account the temporary variables that are generated by the compiler 
that do not exist in the code.


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>
Here is an example that triggers a violation:

struct big_variable
{
    char tab[10000];
};

void STACK_LIM_bad(big_variable first, big_variable second) // VIOLATION
{
    char retTab[20000]; // VIOLATION
    // VIOLATION: 
    for (int i = 0; i &lt; 10000; i++) { // VIOLATION
        retTab[i] = first.tab[i];
    }

    for (int i = 10000; i &lt; 20000; i++) {
        retTab[i] = first.tab[i - 10000];
    }

    // do something
}

This code has got three problems:
1. Single stack variable "retTab" takes 20000 bytes (limit 4096 bytes).
2. All method header parameters takes 20000 bytes (limit 256 bytes).
3. Local variables and parameters takes maximally 40004 bytes on the stack 
(limit 20480 bytes).


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>
Pass parameters using references instead of passing by value.
Create array on the heap instead of creating on the stack.

struct big_variable
{
    char tab[10000];
};

void STACKLIM_good(big_variable &amp; first, big_variable &amp; second)
{
    char * retTab = new char [20000];
    for (int i = 0; i &lt; 10000; i++) {
        retTab[i] = first.tab[i];
    }

    for (int i = 10000; i &lt; 20000; i++) {
        retTab[i] = first.tab[i - 10000];
    }

    // do something
}


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>
2022 CWE Top 25 Most Dangerous Software Errors
2019 CWE Top 25 Most Dangerous Software Errors
CWE-400: Uncontrolled Resource Consumption
<A HREF="http://cwe.mitre.org/data/definitions/400.html">http://cwe.mitre.org/data/definitions/400.html</A>

CWE-404: Uncontrolled Resource Consumption ('Resource Exhaustion')
<A HREF="http://cwe.mitre.org/data/definitions/400.html">http://cwe.mitre.org/data/definitions/400.html</A>

</PRE>
</BODY>
</HTML>
