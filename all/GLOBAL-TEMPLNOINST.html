<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
All class templates, function templates, class template member functions and class template static members shall be instantiated at least one [GLOBAL-TEMPLNOINST]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
All class templates, function templates, class template member functions and class template static members shall be instantiated at least one [GLOBAL-TEMPLNOINST-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"All class templates, function templates, class template member functions and
class template static members shall be instantiated at least once."
[MISRA C++:2008 Rule 14-7-1]

This rule detects uninstantiated class templates, function templates, class template
member functions and class template static members.



</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>

v10.3



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule analyzes declarations and definitions in files in the testing scope.
For this reason, the set of findings reported for the same file may vary
depending on the scope of analysis.

The rule operates on all files in the testing scope. For this reason, it is
important to specify a testing scope that reflects the system architecture
(for example, it may be appropriate to define a testing scope that corresponds
to a single, complete, linkable module).



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

"Similar to uncalled functions, un-instantiated class and function templates
are a potential source of noise and they may be a symptomatic of a more serious
problem such as missing paths" [MISRA C++:2008 Rule 14-7-1]



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

/* test1.cpp */
template &lt;typename T&gt; class A1 {};        /* Violation */
template &lt;typename T&gt; void f1(){}         /* Violation */

template &lt;typename T&gt;
struct ST {                               /* Violation */
  void f1();                              /* Violation */
};

template &lt;typename T&gt;
struct ST2 {                              /* Violation */
  static int s1;                          /* Violation */
};
  


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

/* test1.cpp */
template &lt;typename T&gt; class A1 {};        /* OK */
template &lt;typename T = int&gt; class A6 {};  /* OK */

template &lt;typename T&gt; void f1(int){}      /* OK */
template &lt;typename T&gt; void f2(int){}      /* OK */

template &lt;typename T&gt;               
struct ST {                               /* OK */
  void f1(int);                           /* OK */
};

template &lt;typename T&gt;
struct ST2 {                              /* OK */
  static int s1;                          /* OK */
};

static void instances(ST&lt;int&gt; s, int i) {
   A1&lt;int&gt; a1;
   f2&lt;int&gt;(i);   
   s.f1(i);
   ST2&lt;int&gt; st2;
   st2.s1;
}

template class A6&lt;int*&gt;;
template void f1&lt;int&gt;(int);
   


</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. MISRA C++:2008 Guidelines for the use of the C++ language in critical systems
   Chapter 6, Section 14, Rule 14-7-1

</PRE>
</BODY>
</HTML>
