<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
All member variables should be initialized in constructor [HICPP-12_4_2-a]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
All member variables should be initialized in constructor [HICPP-12_4_2-a-1]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

Constructors of 'class' and 'struct' should initialize all member variables.

The rule checks if a member variable is initialized:
- in constructor initialization list
- inside body of constructor
- inside body of function called from constructor (three levels of nested
  function's calls are checked)
- directly in class (C++11).

If there is no constructor at all a violation is reported for 'class' only. 
You can enable INIT-15 to get a violation for 'struct' too.

See also: INIT-10, INIT-14, INIT-15, MISRA-030



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

The rule assumes that member variable might be initialized
by passing its non-const pointer to an external function.

Member variables which are static or have class or struct type are ignored.
Static variables should not be initialized in constructor.
Class/struct variables are assumed to be initialized by their own constructors.

If in constructor is called default copy assignment operator,
then the rule assumes that all member variables are initialized.

If in constructor is called a member function from the current class with
non-accessible body, then this rule assumes that all member variables are
initialized.



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Prevents reading from uninitialized variables.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class C {
public:
    C( );
private:
    int mem_a;
    int mem_b;
    int mem_c;
    int mem_d;
    int mem_e;
};
C::C( ) {} // Violation - mem_a, mem_b, mem_c, mem_d, mem_e - not initialized

class D {  // Violation - no constructor at all
public:
    int mem_a;
};
struct E { // OK - mem_a type has no constructor - violation reported on class D
    E() {}
private:
    D mem_a;
};



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

class C {
public:
    C( );
    void init();
    void init2();
    void getPtr(int *);
private:
    int mem_a;  // initialized in constructor initialization list
    int mem_b;  // initialized inside constructor body
    int mem_c;  // initialized inside function 'init' called from constructor
    int mem_d;  // initialized inside function 'init2' called from 'init'
    int mem_e;  // its non-const pointer is passed to an external function.
};
void C::init() {
    mem_c = 2;
    init2();
}
void C::init2() {
    mem_d = 2;
}
C::C( ) : mem_a( 0 ) { // OK - all members are initialized
    mem_b = 1;
    init();
    getPtr(&amp;mem_e);
}

class D {  // OK
public:
    D() : mem_a(0) {}
    int mem_a;
};
struct E {  // OK
    E() {}
private:
    D mem_a;
};

struct F { // OK - no violation reported on 'struct' with no constructor
    void foo();
    int mem_a;
};



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. AUTOSAR C++14 Coding Guidelines
   A12-1-1. Constructors shall explicitly initialize all virtual base classes,
   all direct non-virtual base classes and all non-static data members

2. General Principles of Software Validation;
   Final Guidance for Industry and FDA Staff
   Document issued on: January 11, 2002

3. High Integrity C++ Coding Standard
   12.4.2. Ensure that a constructor initializes explicitly all base classes
   and non-static data members

4. ISO/DIS 26262
   point 8.4.4

5. JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
   Chapter 4.10 Classes, AV Rule 71

6. Scott Meyers, "Effective C++: 55 Specific Ways to Improve
   Your Programs and Design", Third Edition, Addison-Wesley,
   (C) 2005 Pearson Education, Inc., Chapter 1, Item 4

</PRE>
</BODY>
</HTML>
