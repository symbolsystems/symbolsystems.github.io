<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand [MISRA2004-12_8]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand [MISRA2004-12_8-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

"If, for example, the left-hand operand of a left-shift or right-shift
is a 16-bit integer, then it is important to ensure that this is shifted
only by a number between 0 and 15 inclusive.
There are various ways of ensuring this rule is followed. The simplest is for 
the right-hand operand to be a constant (whose value can then be statically 
checked). Use of an unsigned integer type will ensure that the operand is 
non-negative, so then only the upper limit needs to be checked (dynamically
at run-time or by review). Otherwise both limits will need to be checked."
[MISRA C:2004]

The rule reports a violation if:

- the right-hand operand is a simple constant with a negative value or a value
  that exceeds the length (in bits) of the left-hand operand, or

- the right-hand operand is a bitwise '&amp;' operator with an operand containing
  a constant with a negative value or a value that exceeds the length (in bits)
  of the left-hand operand, or

- the right-hand operand is neither a simple constant nor a bitwise '&amp;' 
  operator with an operand containing a simple constant and is not checked by
  specific pattern

The specific pattern recognized by the rule requires the shift operator to be
wrapped by an 'if', 'for', or 'while' statement which checks the operand's
value using relational operators (for operands of signed type, both
"greater then" and "less then" operators must be used, for operands of unsigned
type at least one relational operator must be used).



</PRE>
<STRONG>
NOTES
</STRONG>
<PRE>

If the LHS operand of a shift operator is a complex expression, then the rule
checks its real type instead of underlying/essential type.

void foo(){
    unsigned char uc1, uc2;
    uc1 + uc2 &gt;&gt; 8;   // No Violation - underlying/essential type
                      // is unsigned char, but real type is signed int
}



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Rule makes the code more readable and less confusing.



</PRE>
<STRONG>
DRAWBACKS
</STRONG>
<PRE>

If the right-hand operand is a constant expression the rule requires the use
of run-time value checking. For example:
  signed char c;
  c &lt;&lt; 1+1;  // Violation



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef signed int      int32_t;
void foo( uint16_t p, int32_t i ) 
{
   uint8_t u8a;

   u8a = (uint8_t) (u8a &lt;&lt; 9); /* Violation */
   u8a = (uint8_t) (1u &lt;&lt; 9);  /* Violation - underlying/essential type 
                                  of '1u' is unsigned char */
   u8a = (uint8_t) (u8a &lt;&lt; p); /* Violation */
   u8a = (uint8_t) (u8a &gt;&gt; i); /* Violation */
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

typedef unsigned char   uint8_t;
typedef unsigned short  uint16_t;
typedef signed int      int32_t;
void foo( uint16_t p, int32_t i ) 
{
   uint8_t u8a;
   uint16_t u16a;
 
   u16a = (uint16_t) ((uint16_t) u8a &lt;&lt; 9); /* OK */
   u16a = (uint16_t) ((uint16_t) 1u &lt;&lt; 9);  /* OK */

   if (p &lt;= 8) {
       u8a = (uint8_t) (u8a &lt;&lt; p); /* OK - the upper limit 'p'
                                      needs to be checked */
   }
   
   if (i &gt;= 0 &amp;&amp; i &lt;= 8) {
       u8a = (uint8_t) (u8a &lt;&lt; i); /* OK - both limits 'i'
                                      need to be checked */
   }

   u8a = (uint8_t) (u8a &lt;&lt; 4);     /* OK - constant value in range */
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

1. AUTOSAR C++14 Coding Guidelines
   M5-8-1. The right hand operand of a shift operator shall lie between zero
   and one less than the width in bits of the underlying type of the left hand
   operand

2. High Integrity C++ Coding Standard
   4.2.2. Ensure that data loss does not demonstrably occur in an integral
   expression

3. ISO/IEC 9899:1990 Programming languages -- C
   6.3.7 Bitwise shift operators

4. ISO/IEC 9899:1999 Programming languages -- C
   6.5.7 Bitwise shift operators

5. MISRA C++:2008 - Guidelines for the use of the C++ language in critical
   systems, Chapter 6, Section 5, Rule 5-8-1

6. MISRA-C:2004 Guidelines for the use of the C language in critical systems
   Chapter 6, Section 12, Rule 12.8

7. Origin: Misra Guidelines - Rule 38

</PRE>
</BODY>
</HTML>
