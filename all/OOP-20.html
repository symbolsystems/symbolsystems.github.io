<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Avoid explicit cast from derived to a base class [OOP-20]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Avoid explicit cast from derived to a base class [OOP-20-3]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>

This rule reports violation on any explicit cast from derived to base class.
Such casts are usually unnecessary and scope resolution operator "::" can
be used instead.

Rarely the "::" operator is not applicable. In such cases we recommend to
rewrite the code to avoid using explicit casts.

Explicit casts can be a source of serious and hard to detect errors.
For example the result of cast can be incorrect if the class definition is not
visible (if only forward declaration is seen). At the moment of adding the
cast the class definition is visible (e.g. because appropriate header is
included), but later the #include is removed and only forward declaration is
left. The result of cast might not be correct and program behavior changes,
which passes unnoticed due to explicit cast. 



</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>

Simplifies code, protects from errors.



</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

class Base {  };
class Derived : public Base {  };
void Func() {
   Derived *d = new Derived();
   Base *b = (Base *)d;                      // Violation
}

class Base1 {
    int f();
};
class Base2 {
    int f();
};
class Derived1 : public Base1, public Base2 {  };
int Func1() {
   Derived1 *d = new Derived1();
   return (static_cast&lt;Base1*&gt;(d))-&gt;f();     // Violation
}

class Child1 : public Base1 {};
class Child2 : public Base1 {};
void foo(Child1* c1, Child2* c2, bool b) {
   Base1* p = b ? (Base1*)c1 : (Base1*)c2;   // Violation
}



</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

class Base {  };
class Derived : public Base {  };
void Func() {
   Derived *d = new Derived();
   Base *b = d;	                  // OK - cast removed
}

class Base1 { 
    int f();
};
class Base2 { 
    int f();
};
class Derived1 : public Base1, public Base2 {  };
int Func1() {
   Derived1 *d = new Derived1();
   return d-&gt;Base1::f();          // OK - scope operator used
}

class Child1 : public Base1 {};
class Child2 : public Base1 {};
void foo(Child1* c1, Child2* c2, bool b) {
   Base1* p = 0;
   if (b) {
      p = c1;                     // OK - code rewritten
   } else {
      p = c2;                     // OK - code rewritten
   }
}



</PRE>
<STRONG>
REFERENCES
</STRONG>
<PRE>

JOINT STRIKE FIGHTER, AIR VEHICLE, C++ CODING STANDARDS
Chapter 4.23 Type Conversions, AV Rule 181

</PRE>
</BODY>
</HTML>
