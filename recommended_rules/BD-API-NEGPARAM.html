<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<LINK REL="stylesheet" HREF="book.css" TYPE="text/css">
<TITLE>
Do not pass negative values to functions expecting non-negative arguments [BD-API-NEGPARAM]
</TITLE>
</HEAD>
<BODY BGCOLOR=#FFFFFF>
<STRONG>
Do not pass negative values to functions expecting non-negative arguments [BD-API-NEGPARAM-1]
</STRONG>
<BR><BR>
<STRONG>
DESCRIPTION
</STRONG>
<PRE>
This rule detects cases when a possibly negative value is passed as an argument
to a function that expects a non-negative parameter.

This rule checks values passed to the following functions:
    int close(int non_neg)
    ssize_t read(int non_neg_1, void*, size_t non_neg_2)
    ssize_t write(int non_neg_1, const void*, size_t non_neg_2)
    ssize_t pread(int non_neg_1, void*, size_t non_neg_2, off_t)
    ssize_t pwrite(int non_neg_1, const void*, size_t non_neg_2, off_t)
    void* calloc(size_t non_neg_1, size_t non_neg_2)
    void* malloc(size_t non_neg)
    void* realloc(void*, size_t non_neg)
    void* aligned_alloc(size_t non_neg_1, size_t non_neg_2)
    void* memcpy(void*, const void*, size_t non_neg)
    void* memmove(void*, const void*, size_t non_neg)
    char* strncpy(char*, const char*, size_t non_neg)
    char* strncat(char*, const char*, size_t non_neg)
    int memcmp(const void*, const void*, size_t non_neg)
    int strncmp(const char*, const char*, size_t non_neg)
    size_t strxfrm(char*, const char*, size_t non_neg)
    void* memchr(void*, int, size_t non_neg)
    void* memset(void*, int, size_t non_neg)
    char* strerror(int non_neg)
    int setvbuf(FILE*, char*, int, size_t non_neg)
    int snprintf(char*, size_t non_neg, const char*, ...)
    char* fgets(char*, int non_neg, FILE*)
    size_t fread(void*, size_t non_neg_1, size_t non_neg_2, FILE*)
    size_t fwrite(const void*, size_t non_neg_1, size_t non_neg_2, FILE*)
    int fseek(FILE*, long int non_neg, int) (when the last parameter is set to SEEK_SET(0 assumed))
    int vsnprintf(char*, size_t non_neg, const char*, va_list)

Some of the parameters described above as non_neg are of the unsigned type.
In such cases, the rule checks whether the actual value passed as the function
argument was cast from the negative value of the signed type.     

The following functions are considered to possibly return a negative value:
    int open(const char*, int, ...)
    int creat(const char*, mode_t)
    int open64(const char*, int, ...)
    int creat64(const char*, mode_t)
    long int ftell(FILE*)
 
See also BD-API-BADPARAM, BD-API-CTYPE, BD-API-REVNEGPARAM 


</PRE>
<STRONG>
SINCE
</STRONG>
<PRE>
v10.1


</PRE>
<STRONG>
SECURITY RELEVANCE
</STRONG>
<PRE>
Passing a value that is out of the expected range as a function parameter
violates API, which may cause runtime errors (for example, negative value
passed to a function that expects a non-negative parameter may change into
a large positive value that overflows the expected range).


</PRE>
<STRONG>
PARAMETERS
</STRONG>
<PRE>
The "Report unvalidated violations" parameter can result in more violations,
but possibly also more false positives, being reported. In this mode Flow 
Analysis will not check whether the path of the violation can be reached from
the beginning of the function. In some complicated cases, restricted analysis
depth may prevent Flow Analysis from completing the violation validation
procedure. If this happens, violation can be found only with this parameter 
turned on.


</PRE>
<STRONG>
BENEFITS
</STRONG>
<PRE>
This rule helps you prevent API violations caused by passing negative
parameter to a function (see the SECURITY RELEVANCE section).


</PRE>
<STRONG>
DRAWBACKS
</STRONG>
<PRE>
N/A


</PRE>
<STRONG>
EXAMPLE
</STRONG>
<PRE>

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void* example_1(int size)
{
    if (size == -1) {
        // ..
    }

    return malloc(size); // VIOLATION
}

void example_2(const char* str, char* dest)
{
    int size = -1;

    if (str != 0) {
        size = strlen(str);
    } else {
        str = "";
    }

    memcpy(dest, str, size); // VIOLATION
}


</PRE>
<STRONG>
REPAIR
</STRONG>
<PRE>

#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void* repair_1(int size)
{
    if (size == -1) {
        // ..
        return 0;
    }

    return malloc(size); // NO VIOLATION
}

void repair_2(const char* str, char* dest)
{
    int size = -1;

    if (str != 0) {
        size = strlen(str);
    } else {
        str = "";
        size = 0;
    }

    memcpy(dest, str, size); // NO VIOLATION
}

</PRE>
</BODY>
</HTML>
